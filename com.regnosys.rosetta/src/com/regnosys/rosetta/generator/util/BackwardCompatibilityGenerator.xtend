package com.regnosys.rosetta.generator.util

import org.eclipse.xtext.generator.IFileSystemAccess2

/**
 * Generator provides backward compatibility for models stuck on earlier model versions.
 */
class BackwardCompatibilityGenerator {
	
	def generate(IFileSystemAccess2 fsa) {
		fsa.generateFile('com/rosetta/model/lib/mapper/MapperUtils.java',
			'''
			package com.rosetta.model.lib.mapper;
			
			import java.util.function.Supplier;
			import com.rosetta.model.lib.expression.ComparisonResult;
			
			public class MapperUtils {
				
				/**
				 * Used when generating code for nested if statements
				 */
				public static <T> Mapper<T> fromBuiltInType(Supplier<Mapper<T>> supplier) {
					return supplier.get();
				}
			
				/**
				 * Used when generating code for nested if statements
				 */
				public static <T> Mapper<? extends T> fromDataType(Supplier<Mapper<? extends T>> supplier) {
					return supplier.get();
				}
			
				public static ComparisonResult toComparisonResult(Mapper<Boolean> mapper) {
					if (mapper instanceof ComparisonResult) {
						return (ComparisonResult) mapper;
					} else {
						return mapper.getMulti().stream().allMatch(Boolean::booleanValue) ? ComparisonResult.success() : ComparisonResult.failure("");
					}
				}
			}
			''')
			
		fsa.generateFile('com/rosetta/model/lib/expression/CardinalityOperator.java',
			'''
			package com.rosetta.model.lib.expression;
			
			/**
			 * Generated by com.regnosys.rosetta.generator.util.BackwardCompatabilityGenerator.java.
			 * Provide compatibility for CDM versions before 2.111.0 (which uses DSL version 4.9.1).
			 * Can be removed once all model CDM versions have been updated to 2.111.0.
			 */
			public enum CardinalityOperator {
				All,
				Any
			}
			''')
			
		fsa.generateFile('com/rosetta/model/lib/functions/ModelObjectValidator.java',
			'''
			package com.rosetta.model.lib.functions;
			
			import java.util.List;
			
			import com.google.inject.ImplementedBy;
			import com.rosetta.model.lib.RosettaModelObject;
			
			@ImplementedBy(NoOpModelObjectValidator.class)
			public interface ModelObjectValidator {
			
				/**
				 * Runs validation and collects errors. Implementation may throw an exception if validation fails.
				 * 
				 * @param <T>
				 * @param clazz
				 * @param object
				 * @throws ModelObjectValidationException if validation fails
				 */
				<T extends RosettaModelObject> void validate(Class<T> clazz, T object);
			
				/**
				 * Runs validation and collects errors. Implementation may throw an exception if validation fails.
				 * 
				 * @param <T>
				 * @param clazz
				 * @param objects
				 * @throws ModelObjectValidationException if validation fails
				 */
				<T extends RosettaModelObject> void validate(Class<T> clazz, List<? extends T> objects);
			
			
				class ModelObjectValidationException extends RuntimeException {
					
					private final String errors;
			
					public ModelObjectValidationException(String errors) {
						super(errors);
						this.errors = errors;
					}
			
					public String getErrors() {
						return errors;
					}
				}
			}
			''')
			
		fsa.generateFile('com/rosetta/model/lib/functions/NoOpModelObjectValidator.java',
			'''
			package com.rosetta.model.lib.functions;
			
			import java.util.List;
			
			import com.rosetta.model.lib.RosettaModelObject;
			
			public class NoOpModelObjectValidator implements ModelObjectValidator {
			
				@Override
				public <T extends RosettaModelObject> void validate(Class<T> clazz, T object) {
					// do nothing
				}
			
				@Override
				public <T extends RosettaModelObject> void validate(Class<T> clazz, List<? extends T> objects) {
					// do nothing
				}
			
			}

			''')
			
		fsa.generateFile('com/rosetta/model/lib/functions/ConditionValidator.java',
			'''
			package com.rosetta.model.lib.functions;
			
			import java.util.function.Supplier;
			
			import com.google.inject.ImplementedBy;
			import com.rosetta.model.lib.expression.ComparisonResult;
			
			/**
			 * Generated by com.regnosys.rosetta.generator.util.BackwardCompatabilityGenerator.java.
			 * Provide compatibility for CDM versions before 2.175.0 (which uses DSL version 4.42.0).
			 * Can be removed once all model CDM versions have been updated to 2.175.0.
			 */
			@ImplementedBy(DefaultConditionValidator.class)
			public interface ConditionValidator {
			
				/**
				 * Evaluates conditions. Implementation may throw an exception if condition fails.
				 * 
				 * @param condition
				 * @param description
				 * @throws ConditionException if condition fails
				 */
			    void validate(Supplier<ComparisonResult> condition, String description);
			
			
			    class ConditionException extends RuntimeException {
			
			        public ConditionException(String message) {
			            super(message);
			        }
			
			        public ConditionException(String message, Throwable cause) {
			            super(message, cause);
			        }
			    }
			}
			''')
			
		fsa.generateFile('com/rosetta/model/lib/functions/DefaultConditionValidator.java',
			'''
			package com.rosetta.model.lib.functions;
			
			import java.util.function.Supplier;
			
			import com.rosetta.model.lib.expression.ComparisonResult;
			
			/**
			 * Generated by com.regnosys.rosetta.generator.util.BackwardCompatabilityGenerator.java.
			 * Provide compatibility for CDM versions before 2.175.0 (which uses DSL version 4.42.0).
			 * Can be removed once all model CDM versions have been updated to 2.175.0.
			 */
			public class DefaultConditionValidator implements ConditionValidator {
			    @Override
			    public void validate(Supplier<ComparisonResult> condition, String description) {
			        if (!condition.get().get()) {
			            throw new ConditionException(description);
			        }
			    }
			}
			''')
			
		fsa.generateFile('com/rosetta/model/lib/mapper/MapperS.java',
			'''
			package com.rosetta.model.lib.mapper;
			
			import static com.rosetta.model.lib.mapper.MapperItem.getMapperItem;
			import static com.rosetta.model.lib.mapper.MapperItem.getMapperItems;
			
			import java.util.ArrayList;
			import java.util.Arrays;
			import java.util.Collections;
			import java.util.List;
			import java.util.Optional;
			import java.util.function.Function;
			import java.util.stream.Stream;
			
			import com.rosetta.model.lib.RosettaModelObject;
			
			
			public class MapperS<T> implements MapperBuilder<T> {
			
				private final MapperItem<T,?> item;
				private final boolean identity;
				
				public MapperS(MapperItem<T,?> item) {
					this(item, false);
				}
				
				public MapperS(MapperItem<T,?> item, boolean identity) {
					this.item = item;
					this.identity = identity;
				}
				
				public static <T> MapperS<T> identity() {
					return new MapperS<>(new MapperItem<>(null, MapperPath.builder().addNull(), true, Optional.empty()), true);
				}
				
				public static <T> MapperS<T> ofNull() {
					return new MapperS<>(new MapperItem<>(null, MapperPath.builder().addNull(), true, Optional.empty()));
				}
			
				public static <T> MapperS<T> of(T t) {
					if (t==null) {
						return new MapperS<>(new MapperItem<>(t, MapperPath.builder().addNull(), true, Optional.empty()));
					}
					if (t instanceof RosettaModelObject) {
						return new MapperS<>(new MapperItem<>(t, MapperPath.builder().addRoot(((RosettaModelObject)t).getType()), false, Optional.empty()));
					}
					return new MapperS<>(new MapperItem<>(t, MapperPath.builder().addRoot(t.getClass()), false, Optional.empty()));
				}
				
				public static <T,P> MapperS<T> of(T t, MapperPath path, MapperItem<P, ?> parent) {
					if (t==null) { 
						return new MapperS<>(new MapperItem<>(t, path, true, Optional.ofNullable(parent)));
					}
					return new MapperS<>(new MapperItem<>(t, path, false, Optional.ofNullable(parent)));
				}
				
				@Override
				public <F> MapperS<F> map(String name, Function<T, F> mappingFunc) {
					return map(new NamedFunctionImpl<>(name, mappingFunc));
				}
				
				/**
				 * Maps single parent item to single child item.
				 */
				@Override
				public <F> MapperS<F> map(NamedFunction<T, F> mappingFunc) {
					return new MapperS<>(getMapperItem(item, mappingFunc));
				}
				
				@Override
				public <F> MapperC<F> mapC(String name, Function<T, List<? extends F>> mappingFunc) {
					return mapC(new NamedFunctionImpl<T, List<? extends F>>(name, mappingFunc));
				}
				
				/**
				 * Maps single parent item to list child item.
				 */
				@Override
				public <F> MapperC<F> mapC(NamedFunction<T, List<? extends F>> mappingFunc) {
					return new MapperC<>(getMapperItems(item, mappingFunc));
				}
				
				@Override
				public T get() {
					return item.getMappedObject();
				}
				
				@Override
				public T getOrDefault(T defaultValue) {
					return Optional.ofNullable(item.getMappedObject()).orElse(defaultValue);
				}
				
				@Override
				public List<T> getMulti() {
					return Optional.ofNullable(get())
							.map(Arrays::asList)
							.orElseGet(ArrayList::new);
				}
				
				@Override
				public Optional<?> getParent() {
					return findParent(item)
							.map(MapperItem::getMappedObject);
				}
			
				@Override
				public List<?> getParentMulti() {
					return findParent(item)
							.map(MapperItem::getMappedObject)
							.map(Arrays::asList)
							.orElseGet(ArrayList::new);
				}
			
				@Override
				public int resultCount() {
					return item.getMappedObject()!=null?1:0;
				}
				
				public boolean isIdentity() {
					return identity;
				}
				
				/**
				 * Map a single value into an item of a list based on the given mapping function.
				 * 
				 * @param <F>
				 * @param mappingFunc
				 * @return mapped list
				 */
				public <F> MapperS<F> mapSingleToItem(Function<MapperS<T>, MapperS<F>> mappingFunc) {
					return mappingFunc.apply(this);
				}
				
				/**
				 * Map a single value into an item of a list based on the given mapping function.
				 * 
				 * @param <F>
				 * @param mappingFunc
				 * @return mapped list
				 */
				public <F> MapperC<F> mapSingleToList(Function<MapperS<T>, MapperC<F>> mappingFunc) {
					return mappingFunc.apply(this);
				}
				
				/**
				 * Apply a function to this mapper
				 */
				public <F> F apply(Function<MapperS<T>, F> f) {
					return f.apply(this);
				}
				
				/* (non-Javadoc)
				 * @see com.rosetta.model.lib.blueprint.Mapper#getPath()
				 */
				@Override
				public List<Path> getPaths() {
					return !item.isError() ? Collections.singletonList(item.getPath()) : Collections.emptyList();
				}
				
				/* (non-Javadoc)
				 * @see com.rosetta.model.lib.blueprint.Mapper#getPath()
				 */
				@Override
				public List<Path> getErrorPaths() {
					return item.isError() ? Collections.singletonList(item.getPath()) : Collections.emptyList();
				}
				
				/* (non-Javadoc)
				 * @see com.rosetta.model.lib.blueprint.Mapper#getError()
				 */
				@Override
				public List<String> getErrors() {
					return item.isError() ? Collections.singletonList(item.getPath().toString() +" was null") : Collections.emptyList();
				}
				
				@Override
				public String toString() {
					return item.getPath().toString();
				}
				
				@Override
				public MapperC<T> unionSame(MapperBuilder<T> other) {
					if(other instanceof MapperS) {
						MapperS<T> otherMapperS = (MapperS<T>) other;
						return new MapperC<>(Arrays.asList(this.item, otherMapperS.item));
					}
					else if(other instanceof MapperC) {
						return new MapperC<>(Collections.singletonList(this.item)).unionSame(other);
					}
					else {
						throw new IllegalArgumentException("Unsupported Mapper type: " + other.getClass().getName());
					}
				}
				
				@Override
				public MapperC<Object> unionDifferent(MapperBuilder<?> other) {
					if(other instanceof MapperS) {
						MapperS<?> otherMapperS = (MapperS<?>) other;
						return new MapperC<>(Arrays.asList(this.item.upcast(), otherMapperS.item.upcast()));
					}
					else if(other instanceof MapperC) {
						return new MapperC<>(Collections.singletonList(this.item.upcast())).unionDifferent(other);
					}
					else {
						throw new IllegalArgumentException("Unsupported Mapper type: " + other.getClass().getName());
					}
				}
			
				@Override
				public int hashCode() {
					final int prime = 31;
					int result = 1;
					result = prime * result + ((item == null) ? 0 : item.hashCode());
					return result;
				}
			
				@Override
				public boolean equals(Object obj) {
					if (this == obj)
						return true;
					if (obj == null)
						return false;
					if (getClass() != obj.getClass())
						return false;
					MapperS<?> other = (MapperS<?>) obj;
					if (item == null) {
						if (other.item != null)
							return false;
					} else if (!item.equals(other.item))
						return false;
					return true;
				}
			
				@Override
				public Stream<MapperItem<T, ?>> getItems() {
					return Stream.of(item);
				}
			}
			''')
	}
}