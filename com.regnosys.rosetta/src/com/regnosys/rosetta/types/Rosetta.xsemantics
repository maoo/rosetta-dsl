system com.regnosys.rosetta.typing.RosettaTyping

validatorExtends AbstractDeclarativeValidator

import com.regnosys.rosetta.rosetta.expression.RosettaExpression
import com.regnosys.rosetta.types.RListType
import com.regnosys.rosetta.types.TypeFactory
import com.regnosys.rosetta.rosetta.expression.RosettaBooleanLiteral
import com.regnosys.rosetta.rosetta.expression.RosettaStringLiteral
import com.regnosys.rosetta.rosetta.expression.RosettaBigDecimalLiteral
import com.regnosys.rosetta.rosetta.expression.RosettaIntLiteral
import com.regnosys.rosetta.rosetta.expression.RosettaBinaryOperation
import com.regnosys.rosetta.types.RType
import com.regnosys.rosetta.rosetta.RosettaCardinality
import static extension com.regnosys.rosetta.types.RBuiltinType.*
import com.regnosys.rosetta.types.RBuiltinType
import com.regnosys.rosetta.rosetta.expression.ArithmeticOperation
import com.regnosys.rosetta.rosetta.expression.EqualityOperation
import com.regnosys.rosetta.rosetta.expression.LogicalOperation
import com.regnosys.rosetta.rosetta.expression.ComparisonOperation
import org.eclipse.xtext.validation.AbstractDeclarativeValidator
import com.regnosys.rosetta.types.TypeValidationUtil
import com.regnosys.rosetta.rosetta.expression.RosettaConditionalExpression
import com.regnosys.rosetta.rosetta.expression.ListLiteral
import com.regnosys.rosetta.rosetta.expression.ExpressionPackage
import com.regnosys.rosetta.rosetta.expression.ModifiableBinaryOperation
import com.regnosys.rosetta.rosetta.expression.CardinalityModifier

inject extension TypeFactory typeFactory
inject extension TypeValidationUtil util

auxiliary {
	comparable(RType t1, RType t2)
	overlap(RosettaCardinality c1, RosettaCardinality c2)
	listComparable(RListType t1, RListType t2)
	join(RType t1, RType t2) : RType
	union(RosettaCardinality c1, RosettaCardinality c2) : RosettaCardinality
	listJoin(RListType t1, RListType t2) : RListType
	
	listTypeCheck(RosettaExpression sourceObject, RListType expected)
	looseListTypeCheck(RosettaExpression sourceObject, RListType expected)
	typeCheck(RosettaExpression sourceObject, RType expected)
	listSubtypeCheck(RosettaExpression sourceObject, RListType expected)
	looseListSubtypeCheck(RosettaExpression sourceObject, RListType expected)
	subtypeCheck(RosettaExpression sourceObject, RType expected)
	comparableListTypeCheck(RosettaBinaryOperation sourceObject)
	comparableTypeCheck(RosettaBinaryOperation sourceObject)
	onlyRightIsSingularCheck(ModifiableBinaryOperation sourceObject)
	looseOnlyRightIsSingularCheck(ModifiableBinaryOperation sourceObject)
	constraintCheck(RosettaExpression sourceObject, RosettaCardinality expected)
	notConstraintCheck(RosettaExpression sourceObject, RosettaCardinality notExpected)
	isLooserConstraintCheck(RosettaExpression sourceObject, RosettaCardinality expected)
}

judgments {
	inferType |- RosettaExpression expression : output RListType
		error "Cannot type " + stringRep(expression) + "."
		source expression
	subtype |- RType subtype <: RType supertype
		error subtype + " is not a subtype of " + supertype
	listSubtype |- RListType subtype <| RListType supertype
		error subtype + " is not a list subtype of " + supertype
}

/****** AUXILIARY DEFINITIONS *******/
auxiliary comparable(RType t1, RType t2) {
	empty |- t1 <: t2
	or
	empty |- t2 <: t1
	or
	return false
}
auxiliary overlap(RosettaCardinality c1, RosettaCardinality c2) {
	(c1.unbounded || c1.sup >= c2.inf) && (c2.unbounded || c2.sup >= c1.inf)
}
auxiliary listComparable(RListType t1, RListType t2) {
	comparable(t1.itemType, t2.itemType)
	overlap(t1.constraint, t2.constraint)
}
auxiliary join(RBuiltinType t1, RBuiltinType t2) {
	if (t1 == t2) {
		return t1
	} else if (t1 == INT && t2 == NUMBER) {
		return t2
	} else if (t1 == NUMBER && t2 == INT) {
		return t1
	} else if (t1 == NOTHING) {
		return t2
	} else if (t2 == NOTHING) {
		return t1
	}
}
auxiliary join(RBuiltinType t1, RType t2) {
	t1 == NOTHING
	return t2
}
auxiliary join(RType t1, RBuiltinType t2) {
	t2 == NOTHING
	return t1
}
auxiliary union(RosettaCardinality c1, RosettaCardinality c2) {
	if (c1.unbounded || c2.unbounded) {
		return createConstraint(Math.min(c1.inf, c2.inf))
	} else {
		return createConstraint(Math.min(c1.inf, c2.inf), Math.max(c1.sup, c2.sup))
	}
}
auxiliary listJoin(RListType t1, RListType t2) {
	val sup = join(t1.itemType, t2.itemType);
	sup !== null
	return createListType(sup, union(t1.constraint, t2.constraint))
}

/****** TYPE VALIDATION UTILITIES *******/
auxiliary listTypeCheck(RosettaExpression sourceObject, RListType expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null) {
		expected.equals(actual)
		or
		fail error unequalListTypesMessage(expected, actual)
			source sourceObject
	}
}
auxiliary looseListTypeCheck(RosettaExpression sourceObject, RListType expected) {
    var RListType actual
    empty |- sourceObject : actual or actual = null
    if (expected !== null && actual !== null) {
        expected.itemType.equals(actual.itemType) && expected.constraint.isSubconstraintOf(actual.constraint)
        or
        fail error unequalListTypesMessage(expected, actual)
            source sourceObject
    }
}
auxiliary typeCheck(RosettaExpression sourceObject, RType expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null) {
		expected.equals(actual.itemType)
		or
		fail error unequalTypesMessage(expected, actual.itemType)
			source sourceObject
	}
}
auxiliary listSubtypeCheck(RosettaExpression sourceObject, RListType expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null && !{empty |- actual <| expected}) {
		fail error notAListSubtypeMessage(expected, actual)
			source sourceObject
	}
}
auxiliary looseListSubtypeCheck(RosettaExpression sourceObject, RListType expected) {
    var RListType actual
    empty |- sourceObject : actual or actual = null
    if (expected !== null && actual !== null && !({empty |- actual.itemType <: expected.itemType} && expected.constraint.isSubconstraintOf(actual.constraint))) {
        fail error notAListSubtypeMessage(expected, actual)
            source sourceObject
    }
}
auxiliary subtypeCheck(RosettaExpression sourceObject, RType expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null && !{empty |- actual.itemType <: expected}) {
		fail error notASubtypeMessage(expected, actual.itemType)
			source sourceObject
	}	
}
auxiliary comparableListTypeCheck(RosettaBinaryOperation sourceObject) {
	var RListType tl
	var RListType tr
	empty |- sourceObject.left : tl or tl = null
	empty |- sourceObject.right : tr or tr = null
	if (tl !== null && tr !== null) {
		tl.listComparable(tr)
		or
		fail error notListComparableMessage(tl, tr)
			source sourceObject
	}
}
auxiliary comparableTypeCheck(RosettaBinaryOperation sourceObject) {
	var RListType tl
	var RListType tr
	empty |- sourceObject.left : tl or tl = null
	empty |- sourceObject.right : tr or tr = null
	if (tl !== null && tr !== null) {
		tl.itemType.comparable(tr.itemType)
		or
		fail error notComparableMessage(tl.itemType, tr.itemType)
			source sourceObject
	}
}
auxiliary onlyRightIsSingularCheck(ModifiableBinaryOperation sourceObject) {
	var RListType tl
    var RListType tr
    empty |- sourceObject.left : tl or tl = null
    empty |- sourceObject.right : tr or tr = null
    if (tl !== null && tr !== null) {
        !tl.constraint.constraintEquals(single) && tr.constraint.constraintEquals(single)
        or
        {
            if (tl.constraint.constraintEquals(single)) {
                if (tr.constraint.constraintEquals(single)) {
                    fail error bothAreSingularMessage(sourceObject)
                        source sourceObject
                        feature ExpressionPackage.Literals.MODIFIABLE_BINARY_OPERATION__CARD_MOD
                } else {
                    fail error notRightIsSingularButLeftIsMessage(tr)
                        source sourceObject.right
                }
            } else {
                fail error notConstraintMessage(single, tr)
                    source sourceObject.right
            }
        }
    }
}
auxiliary looseOnlyRightIsSingularCheck(ModifiableBinaryOperation sourceObject) {
    var RListType tl
    var RListType tr
    empty |- sourceObject.left : tl or tl = null
    empty |- sourceObject.right : tr or tr = null
    if (tl !== null && tr !== null) {
        !tl.constraint.constraintEquals(single) && single.isSubconstraintOf(tr.constraint)
        or
        {
            if (tl.constraint.constraintEquals(single)) {
                if (single.isSubconstraintOf(tr.constraint)) {
                    fail error bothAreSingularMessage(sourceObject)
                        source sourceObject
                        feature ExpressionPackage.Literals.MODIFIABLE_BINARY_OPERATION__CARD_MOD
                } else {
                    fail error notRightIsSingularButLeftIsMessage(tr)
                        source sourceObject.right
                }
            } else {
                fail error notConstraintMessage(single, tr)
                    source sourceObject.right
            }
        }
    }
}
auxiliary constraintCheck(RosettaExpression sourceObject, RosettaCardinality expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null) {
		expected.constraintEquals(actual.constraint)
		or
		fail error notConstraintMessage(expected, actual)
			source sourceObject
	}
}
auxiliary notConstraintCheck(RosettaExpression sourceObject, RosettaCardinality notExpected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (notExpected !== null && actual !== null) {
		!notExpected.constraintEquals(actual.constraint)
		or
		fail error wrongConstraintMessage(notExpected, actual)
			source sourceObject
	}
}
auxiliary isLooserConstraintCheck(RosettaExpression sourceObject, RosettaCardinality expected) {
	var RListType actual
	empty |- sourceObject : actual or actual = null
	if (expected !== null && actual !== null) {
		expected.isSubconstraintOf(actual.constraint)
		or
		fail error notLooserConstraintMessage(expected, actual)
			source sourceObject
	}
}

/*** SUBTYPING **/
rule SBuiltIn // SA-Refl, SA-Num, SA-Nothing
	G |- RBuiltinType t1 <: RBuiltinType t2
from {
	{
		t1 == t2
	} or
	{
		t1 == INT
		t2 == NUMBER
	} or {
		t1 == NOTHING
	}
}

rule SNothing // SA-Nothing
	G |- RBuiltinType t1 <: RType t2
from {
	t1 == NOTHING
}

/*** LIST SUBTYPING ***/
rule SList // SA-List
	G |- RListType s <| RListType t
from {
	G |- s.itemType <: t.itemType
	s.constraint.isSubconstraintOf(t.constraint)
}


/*** TYPING ***/
axiom TBoolean
	G |- RosettaBooleanLiteral bool : singleBoolean
axiom TString
	G |- RosettaStringLiteral str : singleString
axiom TNumber
	G |- RosettaBigDecimalLiteral num : singleNumber
axiom TInt
	G |- RosettaIntLiteral i : singleInt

rule TArithmetic
	G |- ArithmeticOperation op : RListType lt
from {
	if (op.operator == '/') {
		lt = singleNumber
	} else {
		G |- op.left : var RListType t1
		G |- op.right : var RListType t2
		if (op.operator == '+' && (t1.equals(singleString) || t2.equals(singleString))) {
			lt = singleString
		} else if (t1.equals(singleNumber) || t2.equals(singleNumber)) {
			lt = singleNumber
		} else {
			lt = singleInt
		}
	}
}

axiom TEquality
	G |- EqualityOperation op : singleBoolean
axiom TLogical
	G |- LogicalOperation op : singleBoolean
axiom TComparison
	G |- ComparisonOperation op : singleBoolean

rule TIf
	G |- RosettaConditionalExpression e : RListType t
from {
	var RListType tthen
	var RListType telse
	empty |- e.ifthen : tthen or tthen = null
	empty |- e.elsethen : telse or telse = null
	if (tthen !== null && telse !== null) {
		t = listJoin(tthen, telse)
	}
}

rule TList
	G |- ListLiteral e : RListType t
from {
	val telems = newArrayList
	if (e.elements.forall[
		var RListType telem
		empty |- it : telem or telem = null
		if (telem === null) {
			false
		} else {
			telems.add(telem)
			true
		}
	]) {
		t = telems.fold(emptyNothing, [ RListType acc, RListType telem |
			if (acc === null) {
				null
			} else {
				val sup = join(telem.itemType, acc.itemType);
				if (sup === null) {
					null
				} else {
					createListType(sup, telem.constraint + acc.constraint)
				}
			}
		])
	}
}

/****** CHECK RULES ********/
checkrule CheckLeftArithmetic for
	ArithmeticOperation op
from {
	if (op.operator == '+') {
		{
			looseListTypeCheck(op.left, singleString)
		} or {
			looseListSubtypeCheck(op.left, singleNumber)
		}
	} else {
		looseListSubtypeCheck(op.left, singleNumber)
	}
}
checkrule CheckRightArithmetic for
	ArithmeticOperation op
from {
	if (op.operator == '+') {
		{
			looseListTypeCheck(op.right, singleString)
		} or {
			looseListSubtypeCheck(op.right, singleNumber)
		}
	} else {
		looseListSubtypeCheck(op.right, singleNumber)
	}
}
checkrule CheckAddition for
	ArithmeticOperation op
from {
	if (op.operator == '+') {
		var RListType tl
		var RListType tr
		empty |- op.left : tl or tl = null
		empty |- op.right : tr or tr = null
		if (tl !== null && tr !== null) {
			{
				tl.itemType == STRING
				tr.itemType == STRING
			}
			or
			{
				empty |- tl.itemType <: NUMBER
				empty |- tr.itemType <: NUMBER
			}
			or 
				fail error "Expected arguments to be either both a `string` or both a `number`, but got `" + tl.itemType.toString() + "` and `" + tr.itemType.toString() + "` instead."
					source op
		}		
	}
}

checkrule CheckEqualityOperation for
	EqualityOperation op
from {
	if (op.cardMod === CardinalityModifier.^NONE) {
		comparableListTypeCheck(op)
	} else {
		looseOnlyRightIsSingularCheck(op)
		comparableTypeCheck(op)
	}
}

checkrule CheckLeftLogical for
	LogicalOperation op
from {
	looseListTypeCheck(op.left, singleBoolean)
}
checkrule CheckRightLogical for
	LogicalOperation op
from {
	looseListTypeCheck(op.right, singleBoolean)
}

checkrule CheckLeftComparison for
	ComparisonOperation op
from {
	if (op.cardMod === CardinalityModifier.^NONE) {
		looseListSubtypeCheck(op.left, singleNumber)
	} else {
		subtypeCheck(op.left, NUMBER)
	}
}
checkrule CheckRightComparison for
	ComparisonOperation op
from {
	if (op.cardMod === CardinalityModifier.^NONE) {
		looseListSubtypeCheck(op.right, singleNumber)
	} else {
		subtypeCheck(op.right, NUMBER)
	}
}
checkrule CheckComparison for
	ComparisonOperation op
from {
	if (op.cardMod !== CardinalityModifier.^NONE) {
		looseOnlyRightIsSingularCheck(op)
	}
}

checkrule CheckIfConditionalExpression for
	RosettaConditionalExpression e
from {
	looseListTypeCheck(e.^if, singleBoolean)
}
checkrule CheckBodyConditionalExpression for
	RosettaConditionalExpression e
from {
	var RListType tthen
	var RListType telse
	empty |- e.ifthen : tthen or tthen = null
	empty |- e.elsethen : telse or telse = null
	if (tthen !== null && telse !== null) {
		listJoin(tthen, telse)
		or
		fail error "Types `" + tthen.itemType + "` and `" + telse.itemType + "` do not have a common supertype."
	}
}

checkrule CheckListLiteral for
	ListLiteral e
from {
	val telems = newArrayList
	if (e.elements.forall[
		var RListType telem
		empty |- it : telem or telem = null
		if (telem !== null) {
			telems.add(telem)
		}
		telem !== null
	]) {
		telems.fold(emptyNothing, [ RListType acc, RListType telem |
			if (acc === null) {
				null
			} else {
				val sup = join(telem.itemType, acc.itemType);
				if (sup === null) {
					null
				} else {
					createListType(sup, telem.constraint + acc.constraint)
				}
			}
		]) !== null
		or
		fail error "Elements do not have a common supertype: " + telems.join(', ')["`" + it.itemType + "`"] + "."
	}
}
